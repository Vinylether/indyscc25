import sst
import os
import sys
import random
# A little hacky but does the trick
sys.path.append("./arch")
from vanadislib import *
from mhlib import *
from kinglib import *
from params import *
import argparse

### USAGE ###
#
# DO NOT EDIT THIS FILE
#
# You should pass command line arguments to this file (run `sst p1.py -- --help` to see available arguments

# The following files need to be in the same directory:
# - params.py
# - mhlib.py
# - vanadislib.py
# - kinglib.py

### OUTPUT ###
# The expected output of this script is as follows:
# - stdout-100 : Any output to stdout produced by the app running on the simulated hardware
# - stderr-100 : Any output to stderr produced by the app running on the simulated hardware
# - example1.csv : Statistics output from the simulation. The name/filepath can be modified if desired.
# - Output to stdout that looks like the following. Simulation time will vary depending on the application you simulate.
#
#   $ sst problem.py -- small/basic-io/hello-world/riscv64/hello-world 
#     Masked set for cores: [4]
#     Masked set for l3caches: [14]
#     Selected configuration costs: $2132.0     
#     Python configuration is finished
#     pid=100 tid=100 has exited
#     all process have exited
#     Simulation is complete, simulated time: 8.93741 us

### IMPORTANT ###
# There is one configuration that causes an error. It will be rejected by this script. 
# All other valid configurations are expected to run without errors.
# The configuration is: -n 16 -c medium -t no -x small -y small -s private -z small -b slow -w 6 -m lat

random.seed(100) # Ensure the selection of disabled cores/caches is reproducible

# Get application and any parameters
parser = argparse.ArgumentParser()
parser.add_argument("-e", "--executable", help="The path to the executable the simulation will run", default="beam")
parser.add_argument("-f", "--statfile", help="statistics output file", default="./example1.csv")
# Parameters to configure simulated architecture
parser.add_argument("-n", "--cores", help="The number of cores on the node : {}".format(arg_cores.keys()), type=int, default=next(iter(arg_cores)))
parser.add_argument("-c", "--speed", help="Core type: {}".format(arg_speed.keys()), default=next(iter(arg_speed)))
parser.add_argument("-t", "--smt", help="Number of hardware threads per core: {}".format(arg_smt.keys()), default=next(iter(arg_smt)))
parser.add_argument("-x", "--l1size", help="The size of each L1 cache: {}".format(arg_l1size.keys()), default=next(iter(arg_l1size)))
parser.add_argument("-y", "--l2size", help="The size of each L2 cache: {}".format(arg_l2size.keys()), default=next(iter(arg_l2size)))
parser.add_argument("-z", "--l3size", help="The size of each L3 cache slice: {}".format(arg_l3size.keys()), default=next(iter(arg_l3size)))
parser.add_argument("-s", "--l2org", help="L2 organization: {}".format(arg_l2org), default=arg_l2org[0])
parser.add_argument("-b", "--noc", help="Network on chip: {}".format(arg_noc.keys()), default=next(iter(arg_noc)))
parser.add_argument("-w", "--memchan", help="The number of memory channels: {}".format(arg_memchan), type=int, default=arg_memchan[0])
parser.add_argument("-m", "--memtype", help="Type of memory: {}".format(arg_memtype.keys()), default=next(iter(arg_memtype)))
args = parser.parse_args()


app = os.getenv("VANADIS_EXE", args.executable)
app_args = ["-t",args.cores]

# Error check parameters
if args.cores not in arg_cores:
    print("Error: --core must be in {}. You provided '{}'.".format(arg_cores.keys(), args.cores))
    sys.exit(1)
if args.speed not in arg_speed:
    print("Error: --speed must be in {}. You provided '{}'.".format(arg_speed.keys(), args.speed))
    sys.exit(1)
if args.smt not in arg_smt:
    print("Error: --smt must be in {}. You provided '{}'.".format(arg_smt.keys(),args.smt))
    sys.exit(1)
if args.l1size not in arg_l1size:
    print("Error: --l1size must be in {}. You provided '{}'.".format(arg_l1size.keys(),args.l1size))
    sys.exit(1)
if args.l2size not in arg_l2size:
    print("Error: --l2size must be in {}. You provided '{}'.".format(arg_l2size.keys(),args.l2size))
    sys.exit(1)
if args.l3size not in arg_l3size:
    print("Error: --l3size must be in {}. You provided '{}'.".format(arg_l3size.keys(),args.l3size))
    sys.exit(1)
if args.l2org not in arg_l2org:
    print("Error: --l2org must be in {}. You provided '{}'.".format(arg_l2org,args.l2org))
    sys.exit(1)
if args.noc not in arg_noc:
    print("Error: --noc must be in {}. You provided '{}'.".format(arg_noc.keys(),args.noc))
    sys.exit(1)
if args.memchan not in arg_memchan:
    print("Error: --memchan must be in {}. You provided '{}'".format(arg_memchan,args.memchan))
    sys.exit(1)
if args.memtype not in arg_memtype:
    print("Error: --memtype must be in {}. You provided '{}'.".format(arg_memtype.keys(),args.memtype))
    sys.exit(1)

# Reject problem configuration
if args.cores == 16 and args.speed == "medium" and args.smt == "no" and args.l1size == "small" and args.l2size == "small" and args.l3size == "small" and args.l2org == "private" and args.noc == "slow" and args.memchan == 6 and args.memtype == "lat":
    print("\nWARNING: This is a known bad configuration (causes a FATAL error if run). It is the only bad configuration you should encounter.")
    print("         This configuration is NOT the answer to the questions, keep looking! Exiting SST...\n")
    sys.exit(0)

# Create parameter sets based on script arguments
config = ChipConfig(core_count=args.cores, 
                    core_type=args.speed,
                    smt=args.smt,
                    l1size=args.l1size,
                    l2size=args.l2size,
                    l3size=args.l3size,
                    l2org=args.l2org,
                    noc=args.noc,
                    memchan=args.memchan,
                    memtype=args.memtype
)

# Randomly select cores/caches to be disabled if needed
core_connection_map = [1] * config.mesh_stops
inoperable_core_count = sum(core_connection_map) - config.core_count
masked_core_map = mask(core_connection_map, inoperable_core_count, "cores")

# Disable L3 slices if mesh stops > l3cache_count
l3_connection_map = [1] * config.mesh_stops
inoperable_l3_count = sum(l3_connection_map) - config.l3cache_count
masked_l3_map = mask(l3_connection_map, inoperable_l3_count, "l3caches")

# Determine where memory will be connected on the mesh
# The number of memories can be modified by changing this map
# If 'layout' in example_params.py is modified, this map MUST be modified as well
memory_connection_map = config.getMemoryConnectionMap()
memory_channels = sum(memory_connection_map)

# Create the cores
multicore = Vanadis("core", config.core_count, config.core_frequency, hw_threads=config.core_hw_threads)
multicore.configureCores(config.getCoreParams())
multicore.configureDecoders(config.getDecoderParams())
multicore.configureBranchUnits(config.getBranchParams())
multicore.configureLoadStoreQueues(config.getLSQParams())
multicore.configureOperatingSystem(config.getOSParams())
multicore.configureTLBs(config.getDTLBParams(), dtlb=True)
multicore.configureTLBs(config.getITLBParams(), dtlb=False)
multicore.configureApplication(app, app_args=app_args)

# Add the private caches to cores to create a core complex
l2 = None
if args.l2org == "private":
    multicore.addPrivateL1L2(config.getL1ICacheParams(), config.getL1DCacheParams(), config.getL2CacheParams())
    multicore.getL2Caches().setReplacement(config.l2cache_replacement)

else: # Shared L2 caches
    multicore.addPrivateL1(config.getL1ICacheParams(), config.getL1DCacheParams())
    l2 = DistributedL2("l2cache", config.core_count, config.getL2CacheParams())
    l2.setReplacement(config.l2cache_replacement)

multicore.getL1ICaches().setReplacement(config.l1icache_replacement)
multicore.getL1DCaches().setReplacement(config.l1dcache_replacement)

# Create L3s
l3 = DistributedL3("l3cache", config.l3cache_count, config.getL3CacheParams())
l3.setReplacement(config.l3cache_replacement, for_directory=False)
l3.setReplacement(config.l3cache_dir_replacement, for_directory=True)

# Create memory
memories = InterleavedMemory("memory", memory_channels, config.memory_capacity, interleave_size=config.page_size)
memories.setTimingModelToSimpleDRAM(config.getMemoryParams())
memories.configureControllers(config.getMemoryControllerParams())

## Set up the NoC and connect all the pieces together
noc = KingsleyMesh("mesh", config.noc_x, config.noc_y, 
                   frequency=config.uncore_frequency,
                   data_flit_size = config.noc_data_flit,
                   ctrl_flit_size = config.line_header_size,
                   nic_input_buffer_entries=config.noc_buffer_depth,
                   nic_output_buffer_entries=config.noc_buffer_depth,
                   router_buffer_entries=config.noc_buffer_depth)

# Connect cores and OS cache to NoC
## Vanadis models the OS as a process on its own dedicated core (in addition to the 'normal' cores)
## Connect it to mesh_stop 0 (os_router=0)
noc.connectVanadisCores(multicore, masked_core_map, os_router=0)

# Connect L2s to NoC if needed
if l2 != None:
    noc.connectDistributedCache(l2, masked_core_map)

# Connect L3s to NoC
noc.connectDistributedCache(l3, masked_l3_map)

# Connect memories to NoC
noc.connectMemory(memories, memory_connection_map)

# Finish configuration of the NoC
noc.finalize()

# Enable statistics everywhere, write to CSV
# Modify this configuration to send output to a different format or print more/less often
sst.setStatisticLoadLevel(7)
sst.enableAllStatisticsForAllComponents()
sst.setStatisticOutput("sst.statOutputCSV", {"filepath" : args.statfile})


print("Selected configuration costs: ${}".format(config.getCost()))
print("Python configuration is finished")
